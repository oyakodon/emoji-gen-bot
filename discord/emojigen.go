package discord

import (
	"bytes"
	"fmt"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/bwmarrin/discordgo"

	"github.com/oyakodon/emoji-gen-bot/emoji"
)

const (
	EmojiGenCommandName        = "emoji"
	EmojiGenCommandDescription = "送信されたテキストから絵文字を生成して返します。"

	MsgUnexpectedOperation = "このメッセージは表示されないはずだよ！"
	MsgRestrictedChannel   = "使用できるチャンネルが設定で制限されています... :man_bowing:"

	EmojiGenSubcommandGenerate            = "gen"
	EmojiGenSubcommandGenerateDescription = "絵文字を生成し、サーバーに登録します。"

	EmojiGenSubcommandPreview            = "preview"
	EmojiGenSubcommandPreviewDescription = "絵文字の生成のみ行います。"

	EmojiGenCustomIDYes = "emojigen_yes"
	EmojiGenCustomIDNo  = "emojigen_no"
)

var (
	emojiNameRegex = regexp.MustCompile(`^[a-zA-Z0-9_]{2,}$`)
)

type emojiEvent struct {
	Id     string
	Cancel bool
}

type generatedEmoji struct {
	RawText string
	Data    []byte
}

type EmojiGenBotFont struct {
	Id       string
	Name     string
	FontPath string
}

type EmojiGenBot struct {
	*DiscordBot

	channels        []string
	noticeChannelId string
	timeoutSeconds  int
	fonts           []*EmojiGenBotFont

	ch chan emojiEvent
}

func (b EmojiGenBot) generateEmoji(opts map[string]string) (*generatedEmoji, error) {
	text := opts["text"]
	text = strings.ReplaceAll(text, "\\n", "\n")

	fgcolor, ok := opts["color"]
	if !ok {
		fgcolor = "000000"
	}
	colorcode, _ := strconv.ParseInt("FF"+fgcolor, 16, 0)
	align := emoji.EmojiAlignLeft
	switch opts["align"] {
	case "center":
		align = emoji.EmojiAlignCenter
	case "right":
		align = emoji.EmojiAlignRight
	}

	fontpath := b.fonts[0].FontPath
	if fontchoice, ok := opts["font"]; ok {
		for _, f := range b.fonts {
			if f.Id == fontchoice {
				fontpath = f.FontPath
				break
			}
		}
	}

	data, err := emoji.GenerateEmojiWithFont(
		text,
		int(colorcode),
		emoji.EmojiColorTransparent,
		align,
		fontpath,
	)
	if err != nil {
		return nil, err
	}

	return &generatedEmoji{
		RawText: text,
		Data:    data,
	}, nil
}

func (b EmojiGenBot) respondEmojiPreview(
	s *discordgo.Session,
	i *discordgo.Interaction,
	opts map[string]string,
) error {
	// 絵文字の生成
	emoji, err := b.generateEmoji(opts)
	if err != nil {
		return err
	}

	logger.Infof("Emoji preview generated by %s: text=%s", i.Member.User.Username, emoji.RawText)

	// レスポンス生成
	response := &discordgo.InteractionResponseData{
		Content: "絵文字の生成に成功しました！",
		Flags:   discordgo.MessageFlagsEphemeral,
		Files: []*discordgo.File{
			{
				Name:        "emoji.png",
				ContentType: CONTENT_TYPE_IMAGE_PNG,
				Reader:      bytes.NewReader(emoji.Data),
			},
		},
	}

	return s.InteractionRespond(i, &discordgo.InteractionResponse{
		Type: discordgo.InteractionResponseChannelMessageWithSource,
		Data: response,
	})
}

func (b EmojiGenBot) respondEmojiWithChoice(
	s *discordgo.Session,
	i *discordgo.Interaction,
	opts map[string]string,
) error {
	// 絵文字名のバリデーション
	name := opts["name"]
	if !emojiNameRegex.Match([]byte(name)) {
		var sb strings.Builder
		sb.WriteString(fmt.Sprintf(":x: この絵文字名は利用できません: %s\n", name))
		sb.WriteString("\n")
		sb.WriteString("(絵文字の名前は2文字以上としてください, 英数字と下線(_)のみ使用可能です。)")

		return b.Respond(s, i, sb.String(), true, nil)
	}

	// 絵文字存在チェック
	emojis, err := s.GuildEmojis(b.guildId)
	if err != nil {
		return err
	}
	for _, e := range emojis {
		if e.Name == name {
			return b.Respond(s, i, ":x: この名前の絵文字は登録済みです: "+name, true, nil)
		}
	}

	// 絵文字の生成
	emoji, err := b.generateEmoji(opts)
	if err != nil {
		return err
	}

	// レスポンス生成
	response := &discordgo.InteractionResponseData{
		Content: "絵文字の生成に成功しました！",
		Components: []discordgo.MessageComponent{
			discordgo.ActionsRow{
				Components: []discordgo.MessageComponent{
					discordgo.Button{
						Label:    "登録",
						Style:    discordgo.SuccessButton,
						Disabled: false,
						CustomID: EmojiGenCustomIDYes,
					},
					discordgo.Button{
						Label:    "キャンセル",
						Style:    discordgo.DangerButton,
						Disabled: false,
						CustomID: EmojiGenCustomIDNo,
					},
				},
			},
		},
		Flags: discordgo.MessageFlagsEphemeral,
		Files: []*discordgo.File{
			{
				Name:        name + ".png",
				ContentType: CONTENT_TYPE_IMAGE_PNG,
				Reader:      bytes.NewReader(emoji.Data),
			},
		},
	}

	err = s.InteractionRespond(i, &discordgo.InteractionResponse{
		Type: discordgo.InteractionResponseChannelMessageWithSource,
		Data: response,
	})
	if err != nil {
		return err
	}

	logger.Infof("Emoji generated by %s: name=%s, text=%s", i.Member.User.Username, name, emoji.RawText)

	canceled := true
	for {
		select {
		case e := <-b.ch:
			if e.Id != name {
				continue
			}

			canceled = e.Cancel
		case <-time.After(time.Duration(b.timeoutSeconds) * time.Second):
		}

		s.InteractionResponseDelete(i)
		break
	}
	if canceled {
		logger.Infof("(canceled): :%s:", name)

		_, err = s.FollowupMessageCreate(i, true, &discordgo.WebhookParams{
			Content: "絵文字の登録がキャンセルされました。",
			Flags:   discordgo.MessageFlagsEphemeral,
		})
		return err
	}

	emojifmt, err := b.CreateEmoji(s, name, emoji.Data)
	if err != nil {
		return err
	}
	logger.Infof("Registered new emoji: :%s:", name)

	if b.noticeChannelId != "" {
		count := b.EmojiCount(s)
		max := b.MaxEmojiCount(s)

		var sb strings.Builder
		sb.WriteString(fmt.Sprintf("絵文字が生成されました！ %s\n", emojifmt))
		sb.WriteString(fmt.Sprintf("(残り絵文字スロット: %d/%d)", max-count, max))

		return b.SendMessage(s, b.noticeChannelId, sb.String())
	}

	return nil
}

func (b EmojiGenBot) handleCommand(s *discordgo.Session, i *discordgo.Interaction) {
	option := i.ApplicationCommandData().Options[0]

	// コマンドオプションのパース
	opts := make(map[string]string, 1)
	for _, o := range option.Options {
		opts[o.Name] = o.StringValue()
	}

	var err error
	switch option.Name {
	case EmojiGenSubcommandGenerate:
		err = b.respondEmojiWithChoice(s, i, opts)
	case EmojiGenSubcommandPreview:
		err = b.respondEmojiPreview(s, i, opts)
	}

	if err != nil {
		logger.Warn(err)
		s.FollowupMessageCreate(i, true, &discordgo.WebhookParams{
			Content: "絵文字の生成時にエラーが発生しました...",
			Flags:   discordgo.MessageFlagsEphemeral,
		})
	}
}

func (b EmojiGenBot) handleComponent(s *discordgo.Session, i *discordgo.Interaction) {
	customId := i.MessageComponentData().CustomID

	if len(i.Message.Attachments) == 0 {
		b.Respond(s, i, MsgUnexpectedOperation, true, nil)
		return
	}

	attachment := i.Message.Attachments[0]
	name := strings.ReplaceAll(attachment.Filename, ".png", "")

	switch customId {
	case EmojiGenCustomIDYes:
		b.ch <- emojiEvent{
			Id:     name,
			Cancel: false,
		}
	case EmojiGenCustomIDNo:
		b.ch <- emojiEvent{
			Id:     name,
			Cancel: true,
		}
	}
}

func (b EmojiGenBot) interaction(s *discordgo.Session, i *discordgo.InteractionCreate) error {
	respond := func(message string) error {
		return b.Respond(s, i.Interaction, message, true, nil)
	}

	// 別サーバの際は実行しない
	if i.GuildID != b.guildId {
		return respond(MsgUnexpectedOperation)
	}

	// configのChannelIDに含まれていなくても実行しない
	ok := false
	for _, c := range b.channels {
		if ok = ok || c == i.ChannelID; ok {
			break
		}
	}
	if !ok {
		return respond(MsgRestrictedChannel)
	}

	// インタラクションの種別で分岐
	switch i.Type {
	case discordgo.InteractionApplicationCommand:
		b.handleCommand(s, i.Interaction)
	case discordgo.InteractionMessageComponent:
		b.handleComponent(s, i.Interaction)
	}

	return nil
}

func NewEmojiGenBot(
	bottoken, guildId, nickname, noticechannelid string,
	channels []string,
	fonts []*EmojiGenBotFont,
	timeout int,
) *EmojiGenBot {
	bot := &EmojiGenBot{
		DiscordBot: NewDiscordBot(
			bottoken,
			guildId,
			discordgo.IntentGuildMessages, // サーバメッセージ送信
		),
		channels:        channels,
		noticeChannelId: noticechannelid,
		ch:              make(chan emojiEvent),
		fonts:           fonts,
		timeoutSeconds:  timeout,
	}

	bot.SetNickname(nickname)

	// コマンド共通オプションを定義
	cmdopts := []*discordgo.ApplicationCommandOption{
		{
			Type:        discordgo.ApplicationCommandOptionString,
			Name:        "text",
			Description: "テキスト",
			Required:    true,
		},
		{
			Type:        discordgo.ApplicationCommandOptionString,
			Name:        "color",
			Description: "文字色のカラーコード (ex: FFFFFF)",
			Required:    false,
		},
		{
			Name:        "align",
			Description: "テキストの文字揃え",
			Type:        discordgo.ApplicationCommandOptionString,
			Choices: []*discordgo.ApplicationCommandOptionChoice{
				{
					Name:  "中央揃え",
					Value: "center",
				},
				{
					Name:  "左揃え (デフォルト)",
					Value: "left",
				},
				{
					Name:  "右揃え",
					Value: "right",
				},
			},
			Required: false,
		},
	}

	// 設定からフォントを読み込んで選択肢に追加
	if len(fonts) == 0 {
		panic("No fonts registered in config!")
	}

	fontchoices := make([]*discordgo.ApplicationCommandOptionChoice, 0)
	for _, f := range fonts {
		fontchoices = append(fontchoices, &discordgo.ApplicationCommandOptionChoice{
			Name:  f.Name,
			Value: f.Id,
		})
	}

	cmdopts = append(cmdopts, &discordgo.ApplicationCommandOption{
		Name:        "font",
		Description: "文字フォント",
		Type:        discordgo.ApplicationCommandOptionString,
		Choices:     fontchoices,
		Required:    false,
	})

	// 生成コマンド: 絵文字名のオプションを追加
	cmdoptsgen := append([]*discordgo.ApplicationCommandOption{
		{
			Type:        discordgo.ApplicationCommandOptionString,
			Name:        "name",
			Description: "絵文字名",
			Required:    true,
		},
	}, cmdopts...)

	bot.AddCommand(&discordgo.ApplicationCommand{
		Name:        EmojiGenCommandName,
		Description: EmojiGenCommandDescription,
		Options: []*discordgo.ApplicationCommandOption{
			{
				Name:        EmojiGenSubcommandGenerate,
				Description: EmojiGenSubcommandGenerateDescription,
				Type:        discordgo.ApplicationCommandOptionSubCommand,
				Options:     cmdoptsgen,
			},
			{
				Name:        EmojiGenSubcommandPreview,
				Description: EmojiGenSubcommandPreviewDescription,
				Type:        discordgo.ApplicationCommandOptionSubCommand,
				Options:     cmdopts,
			},
		},
	})
	bot.AddInteraction(bot.interaction)

	return bot
}
